# Git 知识点总结（完整版）

## 1. Git 基础操作

* **查看版本**

  ```bash
  git --version
  ```
* **克隆仓库**

  ```bash
  git clone <repo-url>
  ```
* **查看状态**

  ```bash
  git status
  ```
* **添加文件到暂存区**

  ```bash
  git add <file>
  git add .   # 添加所有修改
  ```
* **提交修改**

  ```bash
  git commit -m "message"
  git commit -am "message"   # 修改的文件直接添加+提交
  ```
* **推送到远端**

  ```bash
  git push
  ```
* **拉取更新**

  ```bash
  git pull             # fetch + merge
  
  git pull --rebase    # fetch + rebase（推荐）

  git fetch --prune（修剪）
  # 远端分支被删除后，这个命令会获取远程最新信息，自动删除本地跟踪的已删除远程分支

  git remote prune origin 
  # 远端分支被删除后，这个命令可以自动删除本地跟踪的远程分支引用，清理本地已不存在的远程分支
  ```

* **远端重命名**
  ```bash
  # 更新远程仓库 URL 到新的地址
  git remote set-url origin https://github.com/<用户名>/<仓库名>.git
  ```

> **三种 `git push` 的对比**

| 命令                     | 含义                                            | 适用场景                                               | 是否需要指定分支     |
| ---------------------- | --------------------------------------------- | -------------------------------------------------- | ------------ |
| `git push`             | 将当前分支推送到默认远程仓库的同名分支                           | 已经设置了远程仓库和默认分支的情况（例如执行过 `git push -u origin main`） | 否            |
| `git push origin`      | 将当前分支推送到远程仓库 `origin` 中与当前分支同名的分支             | 当你只想指定远程仓库而不写分支名时                                  | 否（自动匹配当前分支名） |
| `git push origin main` | 明确指定将本地 `main` 分支推送到远程仓库 `origin` 的 `main` 分支 | 最常用、最安全的推送方式，适合首次推送或多分支项目                          | 是            |


> **三种 `git push`、`git push origin`、`git push origin main` 是否都正确**

| 命令                     | 是否语法正确 | 是否总能执行成功             | 依赖条件                  |
| ---------------------- | ------ | -------------------- | --------------------- |
| `git push`             | ✅ 正确   | ❌ 不一定                | 必须已设置默认上游分支（upstream） |
| `git push origin`      | ✅ 正确   | ⚠️ 取决于当前分支是否已存在于远程仓库 | 当前分支名需与远程同名           |
| `git push origin main` | ✅ 正确   | ✅ 最稳定、最通用            | 无需额外配置                |


## 1️⃣`git pull` 深入讲解

`git pull` **不是简单地直接拉取远程文件并覆盖你工作区的文件**。

`git pull` 是一个**复合命令**，它通常执行以下两个步骤：

1.  **`git fetch`**：从远程仓库下载最新的代码和历史记录到本地的**远程跟踪分支**中（例如 `origin/main`）。
2.  **`git merge`**：将刚刚下载的远程跟踪分支的内容，**合并（merge）**到你当前所在的本地分支中。

### 关键点在于“合并” (Merge)

因为 `git pull` 默认执行的是 **合并**，所以它遵循 Git 的合并规则：

* **如果你的本地工作区和暂存区是干净的 (clean)**，并且你当前的分支落后于远程分支（你没有做任何本地提交）：
    * Git 会执行 **快进式合并 (Fast-Forward Merge)**，直接移动你的本地分支指针，这看起来就像是“更新”了你的文件。

* **如果你在本地有新的提交，并且远程也有新的提交 (历史分叉)**：
    * Git 会执行一个标准的 **三方合并 (Three-Way Merge)**，尝试将你的本地修改和远程的修改智能地整合在一起，生成一个新的合并提交 (Merge Commit)。

* **如果你在本地修改了与远程分支相同的文件或代码行**：
    * **Git 会停止并报告合并冲突 (Merge Conflict)**。你需要手动解决这些冲突，然后才能完成合并。

### 总结

| 情况 | `git pull` 的行为 | 结果 |
| :--- | :--- | :--- |
| **工作区干净** 且 **无本地提交** | **快进合并** | 文件被更新到远程状态，**看起来像覆盖**。 |
| **工作区干净** 且 **有本地提交** | **三方合并** | 尝试智能整合本地和远程的修改，并生成一个**合并提交**。 |
| **有冲突修改** | **报错并停止** | Git 让你手动解决冲突，**不会自动覆盖**。 |
| **工作区不干净** (有未暂存的修改) | **通常会失败** | Git 害怕你的未提交工作丢失，会拒绝合并/拉取。 |

因此，`git pull` 是一个安全、智能的同步操作，它**尊重你的本地修改**，并尽量将它们与远程修改整合，**而不是粗暴地覆盖**。

## 2️⃣`git push origin feature1`深入讲解

`feature1` 在这个命令中通常指的是**本地分支**的名字，而 `origin` 才是远程仓库的名字。正确的理解是：

### 1. 结构分解

`git push <远程仓库名> <本地分支名>[:<远程分支名>]`

* **`origin`**: 这是远程仓库的名称，通常是你执行 `git clone` 时自动创建的别名，指向你自己的 Forked 仓库。
* **`feature1`**: 在 `git push origin feature1` 中，`feature1` 默认是**本地分支**的名称。

### 2. `git push origin feature1` 的确切含义

当你执行 `git push origin feature1` 时，Git 执行的操作是：

> 将你**本地**名为 `feature1` 的分支，推送到名为 `origin` 的远程仓库上。

* **如果远程仓库 `origin` 上**已经存在同名分支 `feature1`，那么这次 `push` 会更新那个远程分支。
* **如果远程仓库 `origin` 上**不存在名为 `feature1` 的分支，那么这次 `push` 会在远程仓库上**创建**一个名为 `feature1` 的新分支。

### 3. 你说的“远程分支的名字”

如果你想明确地将本地分支推送到一个**不同名称**的远程分支，你需要使用冒号 `:`：

* **指令：** `git push origin <本地分支名>:<远程分支名>`
* **示例：** `git push origin feature1:new-remote-name`
    * 将本地的 `feature1` 分支，推送到远程 `origin` 仓库上一个名为 `new-remote-name` 的分支。

### 总结

在 `git push origin feature1` 这个标准形式中，第二个参数 (`feature1`) 通常指代**本地分支的名称**，Git 会默认在远程仓库 `origin` 上寻找或创建同名分支。




---

## 2. 暂存区与文件操作

* **从暂存区移除文件**（不删除工作区的修改，相当于"撤销" `git add` 操作）

  ```bash
  git restore --staged <file>
  ```

* **把本地仓库的最新提交，恢复到工作区，丢弃工作区修改**
（HEAD 就是本地仓库的最新提交）

  ```bash
  git restore <file>
  ```

  > **两者表现不同的时刻，就是当文件处于 “已修改，但未暂存” 的状态时：**
  >- 想丢弃修改时： 您使用 `git restore <file>`（不带 `--staged`）。它会丢弃您的代码。
  >- 不想做任何事时： 您使用 `git restore --staged <file>`（带 --staged）。它不会影响工作区，由于文件本来就未暂存，它对暂存区的影响也无法被看到。


* **删除文件**

  ```bash
  git rm <file>
  ```
* **移动/重命名文件**

  ```bash
  git mv oldname newname
  ```

---

## 3. 合并与 Rebase

* `git pull = git fetch + git merge`

  * 会生成额外的 **merge commit (D)**
* `git pull --rebase`

  * 把你的提交“接到”远端最新提交后面，保持历史线性。

设置默认 rebase：

```bash
git config --global pull.rebase true
```

---

## 4. 查看历史

* **查看提交记录**

  ```bash
  git log
  ```


* **常用退出方法**
  - **q**  
  在 `git log` 打开的界面（`less`）中按 `q`，立即退出并返回 shell。（首选）

  - **Ctrl+C**  
  强制中断当前进程，适用在 `q` 无效或卡住时的应急手段。

   - **Ctrl+Z**  
  将 pager 挂起到后台（shell 提示符会回来），可用 `fg` 恢复；不推荐作为常规退出方式，只作临时挂起。
  

* **查看某次提交详情**

  ```bash
  git show <commit-id>
  ```

---

## 5. Git 的“后悔药”

### 1）Discard（丢弃修改，也叫rollback）

* 单个文件（**把本地仓库的最新提交，恢复到工作区，丢弃工作区修改**）：

  ```bash
  git restore <file>
  ```
* 所有文件：

  ```bash
  git reset --hard
  ```

### 2）Reset（重置到历史提交）最常用：

```bash
git reset --mixed <commit-id>
```

⚠️ 若已推送远端 → 需要 `git push -f`（危险，不推荐在公共分支）。

### 3）Revert（安全撤销）

```bash
git revert <commit-id>
```

生成反向提交，抵消历史修改。多人协作推荐。

### 4）Amend（修改最后一次提交）

```bash
git commit --amend
```

* 只能改最新提交
* 若已推送远端 → 需要强推（⚠️ 不要在公共分支使用）

---

## 6. 总结

* **merge** → 会产生额外提交，历史复杂
* **rebase** → 保持线性历史，推荐
* **restore --staged <单文件>** → 把文件从暂存区移回工作区（相当于"撤销" `git add` 操作）
* **四大“后悔药”：Discard、Reset、Revert、Amend**

---

 | Git操作  | Git 命令                           | 使用场景                          | 注意事项                                                                 |
|----------|------------------------------------|-----------------------------------|--------------------------------------------------------------------------|
| discard（丢弃）  | `git restore <文件名>` （单个文件）<br>`git reset --hard` （所有文件） | 工作区的修改还未 commit             | 舍弃掉工作区修改的文件                                                    |
| reset    | `git reset <commit ID>`            | 还原到某个 commit 的状态，舍弃之后的 commit | 如果 reset 已经推送远端的 commit，会造成强制推送，集成分支禁止强推                       |
| revert   | `git revert <commit ID>`           | 使用一个新的提交抵消掉某次 commit 的修改 |                                                                          |
| amend    | `git commit --amend`               | 只能修改最新的一次 commit           | 如果 amend 已经推送远端 commit，会造成强制推送，集成分支禁止强推                         |
